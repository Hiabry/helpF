# Связываем локальный и удалённый репозитории

1. Копируем URL удаленного репозитория типа SSH.


2. Заходим в папку локального репозитория и вставляем следующее в терминал:

**git remote add** - привязать удаленный репозиторий к локальному


```

$ git remote add origin ***URL(SSH)**

```


P.s. origin - имя репозитория


3. Убеждаемся что репозитории связаны:

**git remote -v** - проверка связи


```
$ git remote -v


origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (fetch)


origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (push)

```


4. Отправляем изменения:

**git push** - отправка изменений


впервые: 

```

$ git push -u origin main (master)


```

---
---


# Хеш - основной индитификатор коммита


**git log** - вывести историю коммитов


**Хеширование** (от англ. hash, «рубить», «крошить», «мешанина») — это способ преобразовать набор данных и получить их «отпечаток».


Информация о коммите — это набор данных: когда был сделан коммит, содержимое файлов в репозитории на момент коммита и ссылка на предыдущий, или родительский (англ. parent), коммит.


   - если хеш получить дважды для одного и того же набора входных данных, то результат будет гарантированно одинаковый;
    
    
   - если хоть что-то в исходных данных поменяется (хотя бы один символ), то хеш тоже изменится (причём сильно).


Все хеши и таблицу **хеш → информация о коммите** Git сохраняет в служебные файлы. Они находятся в скрытой папке .git в репозитории проекта.



---
---


# Исследуем лог (от англ. log — «журнал [записей]») - описание коммита


**git log** - вывести список коммитов


### Описание состоит из:

- строка из цифр и латинских букв после слова commit — это хеш коммита;


- Author — имя автора и его электронная почта;


- Date — дата и время создания коммита;


- в конце находится сообщение коммита.


**git log --oneline** - получить сокращенный лог

В терминале появятся только первые несколько символов хеша каждого коммита и их комментарии.
Команда git log --oneline автоматически подбирает такую длину сокращённых хешей, чтобы они были уникальными в пределах репозитория и Git всегда мог понять, о каком коммите идёт речь.


---
---


# HEAD

Файл **HEAD** (англ. «голова», «головной») — один из служебных файлов папки **.git**. Он указывает на коммит, который сделан последним (то есть на самый новый).


Внутри **HEAD** — ссылка на служебный файл: **refs/heads/master** (или refs/heads/main в зависимости от названия ветки). Если заглянуть в этот файл, можно увидеть хеш последнего коммита.


При работе с Git указатель **HEAD** используется довольно часто. Мы уже упоминали, что многие команды Git принимают в качестве параметра хеш коммита. Если нужно передать последний коммит, то вместо его хеша можно просто написать слово **HEAD** — Git поймёт, что вы имели в виду последний коммит.


---
---


# Статусы файлов в Git


- **untracked** - неотслеживаемый


- **staged** - подготовленный - после **git add**


- **tracked** - отслеживаемый - после **git add** и **git commit**


- **modified** - файл был закоммичен и после этого изменён

---


### Цикл жизни файла в Git



``` mermaid

%% Схема цикла жизни файла в Git

graph LR;
 untracked -- "git add" --> staged+tracked;
  staged+tracked    -- "git commit"     --> tracked/comitted;
  modified -- "git add" --> staged+tracked;
  staged+tracked -- "Изменения" --> modified;
  tracked -- "Изменения" --> modified

```


1. Файл только что создали. Git ещё не отслеживает содержимое этого файла. Состояние: **untracked**.


2. Файл добавили в **staging area** с помощью **git add**. Состояние: **staged (+ tracked)**.
     
    
3. Сделали коммит с помощью **git commit**. Состояние: **tracked**.


4. Изменили файл. Состояние: **modified (+ tracked)**.


5. Снова добавили в **staging area** с помощью **git add**. Состояния: **staged (+ tracked)**.


6. Сделали коммит. Состояния: **tracked**.


7. Повторили пункты 4−7 много-много раз.


---
---


# Оформление сообщений к коммитмммам

У каждого коммита в Git есть сообщение — то, что передаётся после параметра **-m**. Например: **git commit -m "Добавить урок про оформление сообщений коммитов"**.


- Типичное правил: *«Сообщение не должно быть длиннее 72 символов»*.


### Сообщение должно быть:


- относительно коротким, чтобы его было легко прочитать;


- информативным.


---


### Корпоративный


Во многих компаниях применяется **Jira** — система для организации проектов и задач. У каждой задачи в **Jira** есть идентификатор из нескольких заглавных латинских букв и номера. Например, **LGS-239** значит, что это 239-я задача в проекте LGS (сокращение от англ. logistics — «логистика»).


В корпоративном стиле в начале сообщения обычно указывают Jira-ID, а после — текст сообщения.


```


$ git commit -m "LGS-239: Дополнить список пасхалок новыми числами" 


```


---


### Conventional Commits (англ. «соглашение о коммитах»)


**Conventional Commits** предлагает такой формат коммита: **<type>: <сообщение>**. Первая часть **type** — это тип изменений. Таких типов достаточно много. Вот два примера:


- feat (сокращение от англ. feature) — для новой функциональности;


- fix (от англ. «исправить», «устранить») — для исправленных ошибок.


```

git commit -m "feat: добавить подсчёт суммы заказов за неделю" 


```

---


### GitHub-стиль



GitHub можно использовать не только для хранения файлов проекта, но и для ведения списка задач (англ. issue) этого проекта. Если коммит «закрывает» или «решает» какую-то задачу, то в его сообщении удобно указывать ссылку на неё. Для этого в любом месте сообщения нужно указать #<номер задачи>. Например, вот так:


```

$ git commit -m "Исправить #334, добавить график температуры"

```


В таком случае GitHub свяжет коммит и задачу.




